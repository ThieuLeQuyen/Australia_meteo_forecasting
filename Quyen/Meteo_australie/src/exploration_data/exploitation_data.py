import os

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.spatial.distance import cdist
import ydata_profiling
import missingno as msno

from src.utils import horizontal_bar_plot, number_of_nan

print(os.getcwd())
fichier_data = "./data/weatherAUS.csv"

df_data = pd.read_csv(fichier_data)


def tweak_data(df: pd.DataFrame):
    return (df
            .replace({'Yes': 1, 'No': 0})
            .set_index(pd.to_datetime(df.Date))
            .drop('Date', axis=1)
            )


df_cleaned_data = tweak_data(df_data)

# =====================================================================================================================
# Variables catégorielles
# =====================================================================================================================

# Location
var = "Location"
fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(10, 14))
counts = df_cleaned_data[var].value_counts()
counts.plot(kind='barh',
            ax=ax,
            fontsize='large',
            color="green").set_title(f"Distribution de la variable {var}")
plt.tight_layout()
fichier_out = "./output/Bar_plot_Location.png"
fig.savefig(fichier_out)

# Les 3 autres variables catégorielles
var_cat = list(df_cleaned_data.select_dtypes(include="category").columns)
var_cat.remove("Location")

fig, ax = plt.subplots(nrows=1, ncols=len(var_cat), figsize=(14, 8))
for i, var in enumerate(var_cat):
    counts = df_cleaned_data[var].value_counts()
    counts.plot(kind='barh',
                ax=ax[i],
                fontsize='large',
                color='green').set_title(var)
plt.tight_layout()
fichier_out = "./output/Bar_plot_Wind_dir.png"
fig.savefig(fichier_out)

# =====================================================================================================================
# Boxplot des variables numériques
# =====================================================================================================================

quantitative_features = list(df_cleaned_data.select_dtypes(include=np.number).columns)
quantitative_features.remove("RainToday")
quantitative_features.remove("RainTomorrow")
print(quantitative_features)

fig_box, axes = plt.subplots(figsize=(20, 20), nrows=4, ncols=4)
axes = axes.reshape(-1)

for i, col in enumerate(quantitative_features):
    # sns.boxplot(df_cleaned_data[col].fillna(np.nan), ax=axes[i])
    sns.boxplot(df_cleaned_data[col], ax=axes[i])
    axes[i].title.set_text(col)

plt.tight_layout(pad=6.0)
fig_box.suptitle("Boxplots des variables quantatives",
                 fontsize=25)
fichier_out = "./output/Boxplot_variables_numeriques.png"
fig_box.savefig(fichier_out)

# =====================================================================================================================
# Histogram des variables numériques
# =====================================================================================================================

fig_hist, axes = plt.subplots(figsize=(20, 20), nrows=4, ncols=4)
axes = axes.reshape(-1)

for i, col in enumerate(quantitative_features):
    sns.histplot(df_cleaned_data[col].fillna(np.nan), ax=axes[i])
    axes[i].set_xlabel("")
    axes[i].set_ylabel("")
    axes[i].title.set_text(col)

plt.tight_layout(pad=5.0)
fig_hist.suptitle("Histograms des variables quantatives",
                  fontsize=25)
fichier_out = "./output/Histogram_variables_numeriques.png"
fig_hist.savefig(fichier_out)

# =====================================================================================================================
# Pairplot
# =====================================================================================================================
quantitative_features = list(df_cleaned_data.select_dtypes(include=np.number).columns)
sns.pairplot(df_data[quantitative_features])
plt.show()

# =====================================================================================================================
# Corrélation
# =====================================================================================================================
quantitative_features = list(df_cleaned_data.select_dtypes(include=np.number).columns)

cmap = sns.diverging_palette(260, 20, as_cmap=True)

fig_corr, ax = plt.subplots(figsize=(20, 20))
corr_mat = df_cleaned_data[quantitative_features].corr()
mask = np.triu(np.ones_like(corr_mat))

sns.heatmap(corr_mat,
            mask=mask,
            annot=True,
            fmt='.2f',
            cmap=cmap,
            ax=ax)
ax.set_title("Corrélation entre les variables numériques", fontsize=20)
plt.tight_layout()

fichier_out = "./output/Correlation_variables_numeriques_originales.png"
fig_corr.savefig(fichier_out)


# =====================================================================================================================
# Déterminer le % de données manquantes pour chaque colonne
# =====================================================================================================================

pct_missing_by_col = ((df_cleaned_data.isna().sum() * 100) / df_cleaned_data.shape[0]).sort_values(
    ascending=False).to_frame()
pct_missing_by_col.columns = ["pct_missing"]
pct_missing_by_col["variable"] = pct_missing_by_col.index

fig_hbar1 = horizontal_bar_plot(pct_missing_by_col, y_name="variable", x_name="pct_missing",
                                fig_size=(14, 14),
                                title="% de données manquantes avant nettoyage",
                                y_label="Variable", x_label="%")

fichier_out = "./output/Barplot_missing_data_by_column.png"
fig_hbar1.savefig(fichier_out)

# =====================================================================================================================
# Déterminer le % de données manquantes pour chaque ligne
# =====================================================================================================================

pct_missing_by_row = ((df_cleaned_data.isna().sum(axis=1) * 100) / df_cleaned_data.shape[1]).to_frame()
pct_missing_by_row.columns = ["pct_missing"]

fig, ax = plt.subplots(1, 1)

ax.hist(pct_missing_by_row, rwidth=0.8,
        bins=[10, 20, 30, 40, 50, 99])
ax.set_xlabel("% des valeurs manquantes par ligne")
ax.set_title("Histogramme des données manquantes par observation")
for rect in ax.patches:
    label = f"{round(100 * rect.get_height() / df_data.shape[0], 2)} %"
    ax.text(rect.get_x() + rect.get_width() / 2, rect.get_height() + 5,
            label, ha="center", va="bottom")

fichier_out = "./output/Barplot_missing_by_row.png"
fig.savefig(fichier_out)
# =====================================================================================================================
# Missingno
# =====================================================================================================================

# matrix of nullity
fichier_out = "./output/matrix_of_nullity.png"
ax = msno.matrix(df_cleaned_data, figsize=(25, 14))
ax.get_figure().savefig(fichier_out)

# heatmap of nullity corrélation
fichier_out = "./output/heatmap_of_nullity_correlation.png"
ax = msno.heatmap(df_cleaned_data, figsize=(20, 14))
ax.get_figure().savefig(fichier_out)

# Dendrogram
fichier_out = "./output/dendrogram_of_nullity.png"
ax = msno.dendrogram(df_cleaned_data, figsize=(20, 14))
ax.get_figure().savefig(fichier_out)

# =====================================================================================================================
# Variable target "RainTomorrow"
# =====================================================================================================================

fig_pie = plt.figure()
plt.pie(df_data.RainTomorrow.value_counts(dropna=True).values,
        labels=df_data.RainTomorrow.value_counts(dropna=True).index,
        autopct='%1.2f%%')
plt.title("Distribution de la variable RainTomorrow")
plt.show()

# =====================================================================================================================
# Variable "Location"
# =====================================================================================================================
quantitative_features = list(df_cleaned_data.select_dtypes(include=np.number).columns)
quantitative_features.remove("RainTomorrow")
print(quantitative_features)

# Déterminer le nombre d'observation de chaque station
df_nb_obs_by_location = df_cleaned_data.Location.value_counts()

# Déterminer le nombre de données manquantes pour chaque station
df_missing_by_location = (df_cleaned_data
                          .pivot_table(index="Location",
                                       values=quantitative_features,
                                       aggfunc=number_of_nan)
                          .sort_values(by=["Sunshine", "Evaporation", "Cloud9am", "Cloud3pm"],
                                       ascending=[False, False, False, False])
                          )

fig_miss_by_loc, ax = plt.subplots(nrows=10, ncols=5, figsize=(14, 40),
                                   sharey=True)
ax = ax.reshape(-1)
list_cols = df_missing_by_location.columns

for i, location in enumerate(df_missing_by_location.index):
    nb_obs = df_nb_obs_by_location.loc[location]

    list_vals = df_missing_by_location.loc[location, :].values
    sns.barplot(y=list_cols, x=list_vals, ax=ax[i])
    ax[i].title.set_text(f"{location} - {nb_obs} obs")
    ax[i].set_xlim(0, 100)

plt.show()

# ===================================================================================
# Déterminer le nombre de données manquantes pour chaque station
quantitative_features = list(df_data.select_dtypes(include=np.number).columns)
df_nb_obs_by_location = df_data.Location.value_counts()
df_missing_by_location = (df_data
                          .pivot_table(index="Location",
                                       values=quantitative_features,
                                       aggfunc=number_of_nan)
                          .sort_values(by=["Sunshine", "Evaporation", "Cloud9am", "Cloud3pm"],
                                       ascending=[False, False, False, False])
                         )

fig_miss_by_loc, ax = plt.subplots(nrows=10, ncols=5, figsize=(20, 40), sharey=True)
ax = ax.reshape(-1)
list_cols = quantitative_features

for i, location in enumerate(df_missing_by_location.index):
    nb_obs = df_nb_obs_by_location.loc[location]

    list_vals = df_missing_by_location.loc[location, :].values
    sns.barplot(y=list_cols, x=list_vals, ax=ax[i])
    ax[i].title.set_text(f"{location} - {nb_obs} obs")
    ax[i].set_xlim(0, 100)

plt.show()